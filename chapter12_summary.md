# Chapter 12: 프로세스 동기화

## 12-1: 동기화

### 동기화의 개념

프로세스들은 서로 협력하며 영향을 주고받는데, 이때 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기 때문에 반드시 동기화되어야 한다.

### 동기화의 의미

**프로세스들 사이의 수행 시기를 맞추는 것**

동기화는 두 가지 목적으로 나뉜다:

- **실행순서 제어**: 프로세스를 올바른 순서로 실행
- **상호배제(Mutual Exclusion)**: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

> 참고: 스레드도 동기화 대상이다.

### 1. 실행순서 제어를 위한 동기화

Reader-Writer 프로세스 예시:

- Reader는 파일에 값이 있을 때만 실행을 이어나갈 수 있음
- 따라서 Writer → Reader 순서가 중요

### 2. 상호배제를 위한 동기화

공유가 불가능한 자원의 동시 사용을 피하기 위함

**은행 계좌 예시:**

- 기존 계좌: 10만원
- 프로세스 A: 2만원 입금
- 프로세스 B: 5만원 입금
- 기대 결과: 17만원
- 실제 결과: 12만원 또는 15만원 (동기화 실패 시)

### 생산자-소비자 문제

**Mutual Exclusion의 유명한 문제**

- **생산자**: 버퍼에 물건 추가 + 총합 변수 +1
- **소비자**: 버퍼에서 물건 제거 + 총합 변수 -1
- **초기 상태**: 물건 10개
- **실행**: 생산자와 소비자를 동시에 10만번 실행
- **기대 결과**: 총합 = 10
- **실제 결과**: 예상과 다른 값 (동기화 실패)

### 공유 자원과 임계 구역

#### 공유 자원 (Shared Resource)

- 전역 변수
- 파일
- 입출력장치
- 보조기억장치 등

#### 임계 구역 (Critical Section)

동시에 실행 시 문제가 발생하는 자원에 접근하는 코드 영역

#### 경쟁 조건 (Race Condition)

여러 프로세스가 동시에 임계 구역 코드를 실행하여 문제가 발생하는 상황

### 상호배제 동기화의 3원칙

1. **Mutual Exclusion**: 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없음
2. **Progress**: 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 함
3. **Bounded Waiting**: 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 함 (무한정 대기 X)

---

## 12-2: 동기화 기법

### 뮤텍스 락 (Mutex Lock)

**탈의실 자물쇠와 같은 개념**

상호배제를 위한 동기화 도구로, 프로세스는 임계 구역에 있음을 알리기 위해 뮤텍스 락을 이용해 잠근다.

#### 뮤텍스 락의 구성 요소

1. **자물쇠**: 프로세스들이 공유하는 전역 변수 `lock`
2. **acquire 함수**: 임계 구역 잠그는 역할
   - 프로세스가 임계 구역 진입 전 호출
   - 이미 잠겨 있다면 계속 무한루프를 돌다가 lock이 풀리면 바로 잠금
   - 이렇게 쉴 새 없이 무한루프로 잠겨있는지 반복 확인하는 것을 **Busy Wait**라 함
3. **release 함수**: 임계 구역 잠금 해제
   - 임계 구역에서의 작업이 끝난 후 호출
   - lock을 false로 변경

#### 뮤텍스 락 기초 코드

```c
// 전역 변수
bool lock = false;

// acquire 함수 (임계 구역 잠금)
acquire() {
    while (lock == true) {
        // busy wait: 계속 대기
    }
    lock = true;
}

// release 함수 (임계 구역 잠금 해제)
release() {
    lock = false;
}
```

#### 뮤텍스 락 사용법

```c
acquire()     // 임계 구역 잠금
// 임계 구역 코드
release()     // 임계 구역 잠금 해제
```

### 세마포 (Counting Semaphore)

**좀 더 일반화된 방식의 동기화 도구**

뮤텍스 락은 하나의 공유 자원에 접근하는 것을 상정한 것이지만, 세마포는 여러 공유 자원이 있는 상황에서도 적용 가능하다.

#### 세마포의 구성 요소

1. **세마포 변수 S**: 공유 자원의 개수
2. **wait 함수**: 자원 요청 시 호출
   - S가 0보다 크면 S를 1 감소시키고 진입
   - S가 0이면 대기
3. **signal 함수**: 자원 반납 시 호출
   - S를 1 증가시킴

#### 세마포 기초 코드

```c
// 세마포 변수 (공유 자원의 개수)
int S = n;  // n은 사용 가능한 자원의 개수

// wait 함수 (자원 요청)
wait() {
    while (S <= 0) {
        // busy wait: 자원이 없으면 계속 대기
    }
    S--;
}

// signal 함수 (자원 반납)
signal() {
    S++;
}
```

#### 세마포 개선 코드 (Busy Wait 문제 해결)

```c
wait() {
    S--;
    if (S < 0) {
        add this process to Queue;  /* 대기 큐에 삽입 */
        sleep();                    /* 대기 상태로 전환 */
    }
}

signal() {
    S++;
    if (S <= 0) {
        remove a process p from Queue;  /* 대기 큐에서 프로세스 제거 */
        wakeup(p);                     /* 프로세스 p를 대기 상태에서 준비 상태로 전환 */
    }
}
```

### Busy Wait 문제와 해결책

#### 문제점

- 뮤텍스 락과 기본 세마포에서 가용한 공유자원이 없는 경우
- 프로세스는 Busy Wait을 무작정 해야 함
- CPU 주기 낭비 발생

#### 해결책

세마포에서 더 나은 방법을 사용:

1. 자원이 없을 때 프로세스를 대기 큐에 삽입
2. 해당 프로세스를 대기 상태로 전환
3. 자원이 반납되면 대기 중인 프로세스를 깨움

### 세마포를 이용한 프로세스 실행 순서 제어

세마포 변수 S를 0으로 설정하고, 순서를 제어하고 싶은 프로세스에 다음과 같이 적용:

- **먼저 실행할 프로세스** 뒤에 `signal()` 함수
- **나중에 실행할 프로세스** 앞에 `wait()` 함수

#### 실행 순서 제어 예시 (P1 → P2)

```c
// 세마포 변수
int S = 0;

// P1 프로세스
P1의 코드 실행
signal();  // S를 1 증가

// P2 프로세스
wait();    // S가 0이면 대기, 1이면 진입 후 S 감소
P2의 코드 실행
```

**결과**: P1이 먼저 실행되든 P2가 먼저 실행되든 **반드시 P1 → P2 순서**로 실행됨

---

## 모니터 (Monitor)

### 모니터의 개념

매번 임계 구역 앞뒤로 일일이 wait, signal 함수를 명시하는 것은 번거롭다. 모니터는 이를 해결하기 위한 고수준 동기화 기법이다.

### 모니터 vs 세마포 비교

#### 세마포 방식 (번거로운 방법)

```c
// 매번 임계구역 앞뒤로 수동 관리
wait(semaphore);     // 진입 전 필수
// 임계구역 코드
signal(semaphore);   // 나갈 때 필수
```

#### 모니터 방식 (자동화된 방법)

```c
monitor BankAccount {
    int balance = 1000;

    withdraw(int amount) {
        // 상호배제는 모니터가 자동 보장!
        // wait/signal은 불필요
        balance -= amount;
    }
}
```

### 모니터의 특징

- **공유 자원**과 **접근 인터페이스**를 묶어서 관리
- 프로세스는 **반드시 인터페이스를 통해서만** 공유 자원에 접근
- 모니터 안에 **항상 하나의 프로세스만** 들어올 수 있어 **상호배제 자동 보장**

### 조건 변수 (Condition Variable)

조건 변수는 **프로세스 실행 순서를 제어**하기 위한 특별한 변수다.

#### 조건 변수가 필요한 상황: 은행 계좌 예시

```c
monitor BankAccount {
    int balance = 1000;
    condition sufficient_funds;  // 조건 변수

    withdraw(int amount) {
        // 상호배제는 자동 보장됨

        while (balance < amount) {
            wait(sufficient_funds);  // "입금 후에 나를 실행해줘"
        }
        balance -= amount;
        console.log("출금 완료");
    }

    deposit(int amount) {
        balance += amount;
        signal(sufficient_funds);   // "이제 출금 프로세스 실행해도 돼"
        console.log("입금 완료");
    }
}
```

**실행 순서**: 잔액이 부족하면 **입금 → 출금** 순서로 실행

#### 조건 변수의 연산

**wait 연산**

- "아직 내가 실행될 때가 아니야, 기다릴게"
- 프로세스를 조건 변수 대기 큐에 삽입
- 모니터가 비게 되어 다른 프로세스 진입 가능

**signal 연산**

- "이제 기다리던 프로세스 실행해도 돼"
- 조건 변수 대기 큐의 프로세스를 깨움
- 깨어난 프로세스가 모니터로 다시 진입

### 모니터의 동기화 제공

1. **상호배제**: 모니터 자체가 자동으로 한 번에 하나의 프로세스만 허용
2. **실행 순서 제어**: 조건 변수를 통해 "누가 먼저, 누가 나중에 실행될지" 결정
