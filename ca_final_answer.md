**답안:**

---

## 정답 및 해설

### 단답형 정답

1. ALU, 레지스터, 제어장치
2. 주소 버스
3. 하드 디스크 (또는 SSD, USB 등)
4. 즉시 주소 지정 방식
5. 스택
6. PUSH
7. 직접 주소 지정 방식
8. 산술 및 논리 연산 수행
9. 메모리 (같은 메모리)
10. 패치(Fetch) 또는 인출
11. 클럭 속도
12. 하드웨어적 스레드
13. 파이프라이닝
14. 멀티코어
15. SRAM
16. 캐시 히트
17. 섹터
18. RPM
19. RAID 1
20. 장치 드라이버

### 서술형 예시 답안

**21번 답안:**

1. CPU가 제어 버스를 통해 메모리에 읽기 신호를 전송한다.
2. 주소 버스를 통해 읽고자 하는 데이터가 저장된 메모리 주소를 전달한다.
3. 메모리가 해당 주소의 데이터를 데이터 버스를 통해 CPU로 전송한다.

**22번 답안:**

- 즉시 주소 지정 방식: 피연산자가 명령어 내에 상수값으로 직접 포함됨
- 직접 주소 지정 방식: 피연산자가 데이터가 저장된 메모리 주소를 직접 가리킨다
- 간접 주소 지정 방식: 피연산자가 실제 데이터 주소를 가리키는 포인터의 주소를 나타냄
- 레지스터 간접 주소 지정 방식: 레지스터가 가리키는 메모리 주소의 데이터를 사용

**23번 답안:**
파이프라인 4단계: 인출(Fetch) → 해석(Decode) → 실행(Execute) → 저장(Store)
파이프라인 위험:

- 데이터 위험: 이전 명령어의 결과가 다음 명령어에 필요할 때
- 제어 위험: 분기 명령어로 인해 명령어 흐름이 변경될 때
- 구조적 위험: 하드웨어 자원이 충돌할 때

**24번 답안:**
CISC:

- 명령어 길이: 가변 길이, 복잡한 명령어
- 실행 시간: 여러 클럭 사이클 필요
- 파이프라이닝: 구현이 어려움
- 예시: x86 아키텍처

RISC:

- 명령어 길이: 고정 길이, 단순한 명령어
- 실행 시간: 대부분 1클럭에 실행
- 파이프라이닝: 최적화되어 구현 용이
- 예시: ARM 아키텍처

**25번 답안:**
슈퍼스칼라: 여러 개의 명령어를 동시에 인출하고 실행하여 명령어 처리량을 증가시킨다.
비순차적 명령어 처리: 명령어 의존성을 고려하여 준비된 명령어를 먼저 실행함으로써 CPU 자원 활용도를 높인다.

**26번 답안:**
DRAM:

- 재충전: 주기적인 재충전 필요
- 속도/집적도: 느리지만 집적도 높음
- 전력: 상대적으로 많이 소모
- 용도: 주기억장치

SRAM:

- 재충전: 전원 공급 시 재충전 불필요
- 속도/집적도: 빠르지만 집적도 낮음
- 전력: 상대적으로 적게 소모
- 용도: 캐시 메모리

**27번 답안:**
논리 주소: CPU가 생성하는 가상적인 주소, 0번지부터 시작하는 연속적 주소 공간
물리 주소: 실제 메모리 하드웨어의 주소

주소 변환 과정:

1. 논리 주소가 한계 레지스터보다 작은지 확인
2. 정상 범위면 베이스 레지스터 값을 더해 물리 주소 생성
3. 범위를 벗어나면 인터럽트 발생하여 메모리 보호

**28번 답안:**
캐시 계층구조:

- L1 캐시: 각 코어에 가장 가까운 캐시, 가장 빠름
- L2 캐시: L1보다 크고 느림, 일반적으로 각 코어마다 할당
- L3 캐시: 여러 코어가 공유하는 더 큰 캐시

참조 지역성:

- 시간 지역성: 최근 참조된 데이터가 다시 참조될 가능성 높음
- 공간 지역성: 참조된 데이터 주변 데이터가 참조될 가능성 높음

이러한 원리로 자주 사용되는 데이터를 캐시에 유지하여 적중률 향상

**29번 답안:**
하드 디스크 접근 시간:

- 탐색 시간: 헤드를 목적 트랙까지 이동시키는 물리적 시간
- 회전 지연: 원하는 섹터가 헤드 위치로 회전해오는 시간
- 전송 시간: 실제 데이터를 읽어오는 시간

가비지 컬렉션: 플래시 메모리는 덮어쓰기가 불가능하여 데이터 수정 시 기존 페이지를 Invalid로 만들고 새 페이지에 기록한다. Invalid 페이지가 누적되어 공간을 낭비하므로 이를 정리하여 Free 상태로 만드는 가비지 컬렉션이 필요하다.

**30번 답안:**
프로그램 입출력: CPU가 지속적으로 장치 상태를 확인하는 방식, CPU 시간 낭비
인터럽트 기반 입출력: 장치가 준비되면 CPU에 신호를 보내는 방식, 효율적
DMA 입출력: CPU 개입 없이 장치와 메모리 간 직접 데이터 전송

사이클 스틸링: 시스템 버스는 공용 자원이므로 DMA 컨트롤러가 CPU가 버스를 사용하지 않을 때 틈틈이 사용하는 방식

**31번 답안:**
스택(LIFO): 나중에 들어간 데이터가 먼저 나오는 구조

- 예시: 함수 호출 시 복귀 주소 저장, 지역 변수 관리

큐(FIFO): 먼저 들어간 데이터가 먼저 나오는 구조

- 예시: 프로세스 스케줄링, I/O 버퍼링

**32번 답안:**
인출 단계: 메모리에서 다음 실행할 명령어를 가져옴 (프로그램 카운터 사용)
해석 단계: 가져온 명령어를 분석하여 어떤 작업을 수행할지 결정 (명령어 레지스터 사용)
실행 단계: 해석된 명령어에 따라 실제 연산 수행 (ALU, 범용 레지스터 사용)
저장 단계: 실행 결과를 레지스터나 메모리에 저장 (범용 레지스터, 메모리 사용)

**33번 답안:**
클럭 속도: 단위 시간당 더 많은 명령어 처리 가능하게 함
멀티코어: 여러 명령어를 동시에 처리하여 병렬성 향상
멀티스레드: 하나의 코어에서 여러 스레드 동시 처리로 자원 활용도 증가

**34번 답안:**
어셈블리 언어: 기계어를 사람이 읽기 쉬운 니모닉으로 표현한 언어
기계어: CPU가 직접 이해할 수 있는 0과 1로 구성된 언어

컴파일 과정: 소스 코드 → 어셈블리 코드 → 기계어

**35번 답안:**
RAID 0: 데이터를 여러 디스크에 분산 저장(스트라이핑)

장점: 빠른 속도
단점: 하나 고장 시 모든 데이터 손실

RAID 1: 동일한 데이터를 두 디스크에 복사(미러링)

장점: 높은 안정성, 쉬운 복구
단점: 저장 공간 50%만 사용

RAID 5: 패리티 정보를 모든 디스크에 분산 저장

장점: 성능과 안정성 균형, 디스크 1개 고장까지 복구 가능
단점: 복잡한 구현, RAID 0보다 느림
