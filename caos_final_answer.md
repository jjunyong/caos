【정답】
【컴퓨터 구조 영역】 (5문제)

1. CPU가 메모리에서 데이터를 읽어오는 과정

주소 버스: CPU가 읽고자 하는 메모리의 주소를 주소 버스를 통해 메모리에 전달
제어 버스: CPU가 제어 버스를 통해 메모리에 읽기 신호를 전송
메모리 동작: 메모리가 해당 주소의 데이터를 준비
데이터 버스: 메모리가 데이터 버스를 통해 요청된 데이터를 CPU로 전송
CPU 수신: CPU가 데이터를 받아 레지스터나 캐시에 저장

2. 명령어 파이프라이닝과 파이프라인 위험

기본 4단계:

인출(Fetch) - 메모리에서 명령어 가져오기
해석(Decode) - 명령어 분석 및 피연산자 준비
실행(Execute) - ALU에서 연산 수행
저장(Write-back) - 결과를 레지스터에 저장

파이프라인 위험 3가지:

구조적 위험: 하드웨어 자원 부족으로 발생 (메모리 포트 부족 등)
데이터 위험: 명령어 간 데이터 의존성으로 발생 (이전 명령어 결과 필요)
제어 위험: 분기 명령어로 인한 PC 변경으로 발생

3. 캐시 메모리 계층 구조와 참조 지역성

계층 구조: L1(가장 빠름, 작음) → L2 → L3(가장 느림, 큼)
참조 지역성 원리:

시간 지역성: 최근 참조된 데이터가 곧 다시 참조될 가능성이 높음
공간 지역성: 참조된 데이터 근처의 데이터가 곧 참조될 가능성이 높음

적중률 향상: 자주 사용되는 데이터를 빠른 캐시에 유지하여 메모리 접근 시간 단축

4. CISC vs RISC 아키텍처 비교

CISC (Complex Instruction Set Computer):

명령어: 가변 길이, 복잡한 명령어
실행 시간: 명령어당 여러 클럭 사이클
파이프라이닝: 복잡하여 구현 어려움
예시: x86 아키텍처 (Intel, AMD)

RISC (Reduced Instruction Set Computer):

명령어: 고정 길이, 단순한 명령어
실행 시간: 대부분 1클럭 사이클
파이프라이닝: 단순하여 구현 용이
예시: ARM, MIPS

5. 하드 디스크 접근 시간과 플래시 메모리 가비지 컬렉션

하드 디스크 접근 시간:

탐색 시간: 헤드가 목표 트랙으로 이동하는 시간
회전 지연: 플래터가 회전하여 목표 섹터가 헤드 아래로 오는 시간
전송 시간: 실제 데이터를 읽거나 쓰는 시간

플래시 메모리 가비지 컬렉션:

필요 이유: 플래시 메모리는 덮어쓰기 불가, 삭제 후 재작성 필요
페이지 상태: Free(사용 가능), Valid(유효한 데이터), Invalid(무효한 데이터)
과정: Invalid 페이지가 쌓이면 Valid 데이터를 다른 블록으로 이동 후 전체 블록 삭제

【운영체제 영역】 (10문제) 6. 문맥 교환(Context Switching)

정의: 현재 실행 중인 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복원하여 CPU를 다른 프로세스에게 할당하는 과정
과정:

현재 프로세스의 레지스터 값, PC, 스택 포인터 등을 PCB에 저장
새로 실행할 프로세스의 PCB에서 상태 정보 복원
메모리 관리 정보 업데이트 (페이지 테이블 등)
새 프로세스 실행 시작

7. 프로세스 메모리 영역 4가지

코드 영역: 실행 파일의 기계어 코드 저장, 읽기 전용
데이터 영역: 전역 변수, 정적 변수 저장
힙 영역: 동적 메모리 할당 영역 (malloc, new), 런타임에 크기 변화
스택 영역: 지역 변수, 함수 매개변수, 반환 주소 저장, LIFO 구조

8. 선점형 vs 비선점형 스케줄링

선점형 스케줄링:

특징: OS가 강제로 CPU를 빼앗아 다른 프로세스에 할당
장점: 빠른 응답 시간, 시분할 처리 가능
단점: 문맥 교환 오버헤드 증가

비선점형 스케줄링:

특징: 프로세스가 자발적으로 CPU를 반납할 때까지 실행
장점: 문맥 교환 오버헤드 적음, 구현 간단
단점: 응답 시간 예측 어려움, convoy effect 발생 가능

9. 다단계 큐 vs 다단계 피드백 큐

다단계 큐: 프로세스가 고정된 큐에 할당, 큐 간 이동 불가
다단계 피드백 큐: 프로세스가 큐 간 이동 가능

CPU 사용 시간이 길면 낮은 우선순위 큐로 이동
에이징 기법으로 기아 현상 해결: 오래 대기한 프로세스를 높은 우선순위 큐로 이동

10. 생산자-소비자 문제와 Race Condition

문제 상황: 생산자가 버퍼에 데이터 추가, 소비자가 버퍼에서 데이터 제거
Race Condition 발생 과정:

생산자와 소비자가 동시에 공유 변수(버퍼 카운트) 접근
생산자: count 값을 레지스터에 로드 → 1 증가 → 메모리에 저장
소비자: count 값을 레지스터에 로드 → 1 감소 → 메모리에 저장
동시 실행 시 최종 결과가 실행 순서에 따라 달라짐

11. 상호배제 동기화 3원칙

Mutual Exclusion (상호 배제): 한 번에 하나의 프로세스만 임계구역 진입

위반 시: Race Condition 발생, 데이터 무결성 파괴

Progress (진행): 임계구역이 비어있으면 진입 요청한 프로세스가 들어갈 수 있어야 함

위반 시: 불필요한 대기, 시스템 효율성 저하

Bounded Waiting (한정 대기): 프로세스가 임계구역 진입을 요청하면 유한 시간 내 진입 가능

위반 시: 기아 현상(Starvation) 발생

12. 식사하는 철학자 문제

구성요소 의미:

철학자: 프로세스
포크: 공유 자원
생각하는 행위: 프로세스의 작업 수행

교착상태 발생 과정:

모든 철학자가 동시에 왼쪽 포크를 집음
각자 오른쪽 포크를 기다리는 상태
아무도 포크를 놓지 않아 무한 대기 상태 발생
교착상태 4조건 모두 만족

13. 교착상태 회피와 안전상태

안전상태: 모든 프로세스가 교착상태 없이 완료될 수 있는 실행 순서(안전 순서열)가 존재하는 상태
불안전상태: 안전 순서열이 존재하지 않는 상태 (교착상태 발생 가능)
자원 할당 방식: 자원 요청 시 가상으로 할당해보고 안전상태가 유지되는지 확인 후 실제 할당 결정 (은행원 알고리즘)

14. 페이지 테이블 엔트리의 4가지 비트

유효 비트: 해당 페이지가 메모리에 적재되어 있는지 여부
보호 비트: 페이지 접근 권한 (읽기, 쓰기, 실행)
참조 비트: 페이지가 참조되었는지 여부 (페이지 교체 알고리즘에 활용)
수정 비트: 페이지 내용이 수정되었는지 여부

스왑 아웃에서의 중요성: 수정된 페이지는 디스크에 저장 후 제거, 수정되지 않은 페이지는 바로 제거 가능

15. 유닉스 파일 시스템 inode 구조

15개 블록 주소 구성:

1~12번: 직접 블록 (파일 데이터 블록 직접 가리킨)
13번: 1차 간접 블록 (블록 주소들을 저장한 블록을 가리킴)
14번: 2차 간접 블록 (1차 간접 블록들의 주소를 저장한 블록)
15번: 3차 간접 블록 (2차 간접 블록들의 주소를 저장한 블록)

역할: 작은 파일은 직접 블록으로 빠른 접근, 큰 파일은 간접 블록으로 확장 가능한 구조 제공
