# Chapter 12: 프로세스 동기화 퀴즈 정답

## 객관식 정답

1. **3) 메모리 관리** - 동기화의 목적은 실행 순서 제어와 상호배제이다.

2. **2) Race Condition** - 여러 프로세스가 동시에 임계 구역에 접근하여 발생하는 문제이다.

3. **4) First Come First Served** - 상호배제 3원칙은 Mutual Exclusion, Progress, Bounded Waiting이다.

4. **4) 위의 모든 것** - Busy Wait, Spin Lock, Active Wait 모두 같은 의미이다.

5. **3) 프로세스를 대기 상태로 만든다** - S≤0이면 해당 프로세스를 대기 큐에 삽입한다.

6. **3) 매번 수동으로 wait/signal을 호출해야 함** - 모니터는 상호배제를 자동으로 보장한다.

7. **2) P1 뒤에 signal(), P2 앞에 wait()** - S=0으로 설정하고 이렇게 배치하면 순서가 보장된다.

8. **2) 총합 변수** - 생산자와 소비자가 공유하는 데이터는 총합 변수이다.

9. **3) 실행 순서 제어** - 조건 변수는 프로세스 실행 순서를 제어하기 위한 도구이다.

10. **4) 위의 모든 것** - 전역 변수, 파일, 입출력 장치 모두 공유 자원이 될 수 있다.

---

## 단답형 정답

1. **임계 구역 (Critical Section)**

2. **acquire**

3. **signal**

4. **조건 변수 (Condition Variable)**

5. **Bounded Waiting**

---

## 서술형 정답

### 1. 생산자-소비자 문제에서 Race Condition 발생 이유와 과정

**문제 상황:**
생산자는 버퍼에 물건을 넣고 총합 변수를 1 증가시키고, 소비자는 버퍼에서 물건을 빼고 총합 변수를 1 감소시킨다. 초기에 물건이 10개 있을 때 생산자와 소비자를 동시에 10만번 실행하면 총합이 10으로 유지될 것으로 기대하지만 실제로는 전혀 다른 값이 나온다.

**Race Condition 발생 과정:**
동기화가 되지 않은 상황에서 생산자와 소비자가 동시에 총합 변수에 접근할 때 문제가 발생한다. 예를 들어 현재 총합이 100이라고 할 때:

1. 생산자 프로세스가 총합 변수(100)를 읽는다
2. 동시에 소비자 프로세스도 같은 총합 변수(100)를 읽는다
3. 생산자는 읽은 값에 1을 더해 101을 계산한다
4. 소비자는 읽은 값에서 1을 빼서 99를 계산한다
5. 생산자가 101을 총합 변수에 저장한다
6. 소비자가 99를 총합 변수에 저장한다 (마지막에 저장한 값이 최종 결과)

이 경우 생산자의 작업이 무시되고 최종 결과는 99가 된다. 반대로 소비자가 먼저 저장하고 생산자가 나중에 저장하면 101이 된다. 기대했던 100이 아닌 99 또는 101이 되는 것이다.

**참고 - 어셈블리 레벨 분석:**
고급 언어의 "총합++" 연산은 어셈블리어로 LOAD → ADD → STORE의 3단계로 분해되며, 각 단계 사이에서 문맥교환이 일어날 수 있어 더 복잡한 Race Condition이 발생할 수 있다.

**해결책:**
동기화를 통해 임계 구역(총합 변수 접근 코드)에 한 번에 하나의 프로세스만 접근하도록 제어해야 한다.

### 2. 뮤텍스 락과 세마포의 차이점

**뮤텍스 락:**

- **목적:** 하나의 공유 자원에 대한 상호배제
- **예시:** 화장실 사용 (한 번에 한 사람만)
- **적합한 상황:** 단일 공유 자원 보호 (파일 하나, 프린터 하나 등)

**세마포:**

- **목적:** 여러 공유 자원에 대한 접근 제어
- **예시:** 주차장 (여러 대 주차 가능, 자리 수만큼)
- **적합한 상황:** 복수 공유 자원 관리 (데이터베이스 연결 풀, 프린터 여러 대 등)

**구체적 차이:**

- 뮤텍스: boolean 변수 (true/false)
- 세마포: 정수 변수 (0, 1, 2, 3...)

### 3. 모니터의 장점 (은행 계좌 출금 예시)

모니터는 세마포에 비해 동기화를 더 편리하게 처리할 수 있는 고수준 동기화 기법이다.

**세마포의 번거로움:**
세마포를 사용할 때는 매번 임계 구역 앞뒤로 일일이 wait()와 signal() 함수를 명시해야 한다. 은행 계좌 출금 예시에서 세마포를 사용하려면 계좌에 접근하기 전에 wait()를 호출하고, 작업을 마친 후에는 반드시 signal()을 호출해야 한다. 이러한 함수 호출을 빼먹거나 잘못 배치하면 동기화 문제가 발생할 수 있다.

**모니터의 편리함:**
반면 모니터는 공유 자원(은행 계좌)과 공유 자원에 접근하기 위한 인터페이스(출금 함수)를 묶어서 관리한다. 프로세스는 반드시 이 인터페이스를 통해서만 공유 자원에 접근할 수 있다. 모니터는 자동으로 한 번에 하나의 프로세스만 모니터 안에 들어올 수 있도록 하여 상호배제를 자동으로 보장한다. 따라서 개발자가 매번 wait()와 signal()을 수동으로 관리할 필요가 없다.

**조건 변수를 통한 실행 순서 제어:**
모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다. 은행 계좌 출금에서 잔액이 부족한 경우, 조건 변수를 사용하여 입금이 완료될 때까지 출금 프로세스의 실행을 중단시킬 수 있다. 조건 변수의 wait() 연산으로 출금 프로세스를 대기 상태로 만들고, 입금이 완료되면 signal() 연산으로 대기 중인 출금 프로세스를 깨울 수 있다.

**핵심 장점:**
모니터의 가장 큰 장점은 기본적인 상호배제는 자동으로 처리되고, 조건 변수는 특별한 실행 순서 제어가 필요할 때만 사용하면 된다는 것이다. 이는 세마포처럼 매번 임계 구역 앞뒤로 동기화 함수를 명시하는 번거로움을 크게 줄여준다.

**참고 코드:**

```c
// 세마포 방식 (번거로움)
wait(account_semaphore);
if (balance >= amount) balance -= amount;
signal(account_semaphore);

// 모니터 방식 (편리함)
monitor BankAccount {
    condition sufficient_funds;  // "잔액이 충분함" 조건

    withdraw(amount) {
        while (balance < amount) {
            wait(sufficient_funds);  // "잔액 충분" 조건을 기다림
        }
        balance -= amount;
        // 여기서 signal 호출 안함 (잔액이 줄어들었으니까)
    }

    deposit(amount) {
        balance += amount;
        signal(sufficient_funds);   // 잔액이 늘어났으니 "충분함" 조건 만족!
    }
}
```

### 4. 상호배제 동기화의 3원칙

**1. Mutual Exclusion (상호배제):**

- **의미:** 한 프로세스가 임계 구역에 있으면 다른 프로세스는 진입 불가
- **위반 시 문제:** Race Condition 발생, 데이터 불일치

**2. Progress (진행):**

- **의미:** 임계 구역이 비어있으면 진입 원하는 프로세스는 들어갈 수 있어야 함
- **위반 시 문제:** 불필요한 대기, 시스템 효율성 저하

**3. Bounded Waiting (한정 대기):**

- **의미:** 프로세스가 임계 구역 진입을 원하면 언젠가는 들어갈 수 있어야 함
- **위반 시 문제:** Starvation 발생, 특정 프로세스가 무한 대기

### 5. 세마포를 이용한 A → B → C 순서 실행 설계

**세마포 변수 설정:**

```c
int S1 = 0;  // A → B 동기화용
int S2 = 0;  // B → C 동기화용
```

**프로세스 설계:**

```c
// 프로세스 A
A의 코드 실행
signal(S1);        // B에게 "이제 실행해도 돼" 신호

// 프로세스 B
wait(S1);          // A가 끝날 때까지 대기
B의 코드 실행
signal(S2);        // C에게 "이제 실행해도 돼" 신호

// 프로세스 C
wait(S2);          // B가 끝날 때까지 대기
C의 코드 실행
```

**동작 원리:**

- 어떤 순서로 프로세스가 시작되더라도 A → B → C 순서 보장
- B는 S1이 1이 될 때까지 대기 (A 완료 후)
- C는 S2가 1이 될 때까지 대기 (B 완료 후)
