# Chapter 14: 가상 메모리 학습 정리

## 14-1. 연속 메모리 할당

연속 메모리 할당 방식과 고려사항, 그리고 잠재적 문제점들을 살펴보겠습니다.

### 스와핑 (Swapping)

메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 있을 수 있습니다. 대기 상태 프로세스나 오랫동안 사용되지 않은 프로세스들을 임시로 보조기억장치의 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 다른 프로세스를 적재하여 실행하는 방식을 **스와핑**이라고 합니다.

```
┌─────────────┐     스왑 아웃     ┌─────────────┐
│    메모리   │ ===============> │  스왑 영역  │
│             │                  │(보조기억장치)│
│             │ <=============== │             │
└─────────────┘     스왑 인      └─────────────┘
```

**스와핑의 효과:**

- 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있음
- 예: 프로세스 A, B, C, D의 크기 합이 메모리 크기보다 크지만 스와핑을 통해 4개 프로세스 동시 실행 가능

**확인 방법:** Linux에서 `free`, `top` 명령으로 swap 영역 크기 확인 가능

### 메모리 할당

프로세스는 메모리 내 빈 공간에 적재되어야 합니다. 빈 공간이 여러 개 있을 때 어디에 할당할지 결정하는 3가지 방식:

| 할당 방식                 | 설명                                                                              | 특징                    |
| ------------------------- | --------------------------------------------------------------------------------- | ----------------------- |
| **최초 적합** (First Fit) | OS가 메모리 내의 빈 공간을 순서대로 검색하다가 적재 가능 공간 발견 시 거기에 배치 | 검색 최소화로 빠른 할당 |
| **최적 적합** (Best Fit)  | 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 배치                           | 공간 효율성 추구        |
| **최악 적합** (Worst Fit) | 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 배치                             | 큰 단편화 방지          |

### 외부 단편화 (External Fragmentation)

연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있습니다.

**외부 단편화 예시:**

```
메모리 상태: [프로세스A][20MB 빈공간][프로세스B][30MB 빈공간][프로세스C]

총 빈 공간: 50MB
하지만 50MB 크기의 새로운 프로세스는 적재 불가능! (연속되지 않음)
```

**해결 방법 1: 메모리 압축 (Compaction)**

```
압축 전: [A][빈공간][B][빈공간][C]
압축 후: [A][B][C][────연속된 큰 빈공간────]
```

**메모리 압축의 단점:**

- 작업 중지 필요
- 메모리 이동으로 인한 오버헤드
- 효율적인 압축 방법 결정의 어려움

**해결 방법 2: 가상 메모리 기법**
→ 특히 **페이징 기법**으로 외부 단편화 문제를 근본적으로 해결!

---

## 14-2. 페이징을 통한 가상 메모리 관리

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술입니다.

### 페이징이란?

프로세스의 논리 주소 공간을 **페이지(Page)**라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임(Frame)**이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤, 페이지를 프레임에 할당하는 가상 메모리 관리 기법입니다.

```
논리 주소 공간          물리 메모리 공간
┌──────────┐           ┌──────────┐
│ 페이지 0 │ ────────> │ 프레임 3 │
├──────────┤           ├──────────┤
│ 페이지 1 │ ────────> │ 프레임 5 │
├──────────┤           ├──────────┤
│ 페이지 2 │ ────────> │ 프레임 2 │
└──────────┘           └──────────┘
```

**페이징에서의 스와핑:**

- 프로세스 전체가 아닌 **페이지 단위**로 스왑 아웃/스왑 인
- Page Out: 메모리 → 보조기억장치
- Page In: 보조기억장치 → 메모리

### 페이지 테이블 (Page Table)

**문제상황:** 프로세스가 메모리에 불연속적으로 배치되면 CPU가 '다음에 실행할 명령어 위치'를 찾기 어려움

**해결책:** 페이지 테이블을 이용하여 물리 주소에는 불연속적이지만 논리 주소에는 연속적으로 보이게 함

```
프로세스 A의 페이지 테이블
┌─────────────┬─────────────┐
│ 페이지 번호 │ 프레임 번호 │
├─────────────┼─────────────┤
│      0      │      3      │
│      1      │      5      │
│      2      │      2      │
└─────────────┴─────────────┘
```

**특징:**

- 프로세스마다 각자의 페이지 테이블 보유
- CPU 내의 **PTBR(Page Table Base Register)**가 현재 프로세스의 페이지 테이블 주소 저장
- 문맥교환 시 PTBR도 함께 변경

**페이징의 장단점:**

- ✅ 외부 단편화 문제 해결
- ❌ 내부 단편화 문제 발생 가능

**내부 단편화 예시:**

```
페이지 크기: 10KB
프로세스 크기: 108KB
→ 마지막 페이지: 8KB만 사용, 2KB 낭비 (내부 단편화)
```

**페이지 크기 설정의 고려사항:**

- 너무 작게 → 내부 단편화 감소, 하지만 페이지 테이블 크기 증가
- 너무 크게 → 페이지 테이블 크기 감소, 하지만 내부 단편화 증가
- Linux: `getconf PAGESIZE` 명령으로 확인 가능

### TLB (Translation Lookaside Buffer)

**문제:** 페이지 테이블 사용 시 메모리 접근 시간이 2배로 증가

1. 페이지 테이블 접근 (1회)
2. 실제 프레임 접근 (1회)

**해결:** CPU 곁에 TLB라는 페이지 테이블의 캐시 메모리 배치

```
     CPU
      │
   ┌─────┐
   │ TLB │ ←── 페이지 테이블의 캐시
   └─────┘
      │
   메모리 접근
```

- **TLB Hit:** 필요한 페이지 정보가 TLB에 존재 → 메모리 접근 1회만 필요
- **TLB Miss:** 페이지 테이블에 접근해야 함 → 메모리 접근 2회 필요

### 페이징에서의 주소 변환

하나의 페이지/프레임은 여러 주소를 포괄하므로 특정 주소 접근을 위해 2가지 정보 필요:

1. 어떤 페이지/프레임에 접근할지
2. 그 페이지/프레임으로부터 얼마나 떨어져 있는지

**논리 주소 구성:**

```
32비트 논리 주소 예시
┌─────────────┬─────────────┐
│ 페이지 번호 │ 변위(Offset)│
│   (N비트)   │  (32-N비트) │
└─────────────┴─────────────┘
```

**주소 변환 과정:**

```
논리 주소: 페이지 번호 + Offset
         ↓ (페이지 테이블 참조)
물리 주소: 프레임 번호 + Offset
```

### 페이지 테이블 엔트리 (PTE)

페이지 테이블의 각 행에는 프레임 번호 외에도 다른 중요한 정보들이 포함됩니다:

| 비트 종류                 | 설명                      | 0일 때         | 1일 때         |
| ------------------------- | ------------------------- | -------------- | -------------- |
| **유효 비트**             | 페이지의 메모리 적재 여부 | 스왑아웃 상태  | 메모리 적재    |
| **보호 비트**             | 페이지 접근 권한          | 읽기 전용      | 읽기/쓰기 가능 |
| **참조 비트**             | CPU 접근 여부             | 접근한 적 없음 | 접근한 적 있음 |
| **수정 비트** (Dirty Bit) | 페이지 수정 여부          | 수정된 적 없음 | 수정된 적 있음 |

**페이지 폴트 (Page Fault) 처리:**
유효 비트가 0인 페이지에 접근할 때 발생

```
1. CPU 작업 백업
2. 페이지 폴트 처리 루틴 실행
3. 원하는 페이지를 메모리로 적재
4. 유효 비트를 1로 변경
5. CPU 해당 페이지 접근 가능
```

**수정 비트의 중요성:**

- 수정 비트 = 0: 스왑 아웃 시 단순 덮어쓰기만 하면 됨
- 수정 비트 = 1: 스왑 아웃 시 보조기억장치에 변경된 내용 저장 필요

### 고급 페이징 기법

#### 쓰기 시 복사 (Copy-on-Write)

```
fork() 직후:
부모 프로세스 ──┐
               ├─→ 동일한 프레임 공유
자식 프로세스 ──┘

쓰기 작업 발생 시:
부모 프로세스 ──→ 기존 프레임
자식 프로세스 ──→ 새로 복제된 프레임
```

**장점:**

- 프로세스 생성 시간 단축
- 메모리 공간 절약

#### 계층적 페이징 (Hierarchical Paging)

페이지 테이블 크기가 클 때 모든 엔트리를 메모리에 두는 것은 낭비입니다.

```
논리 주소 구성 (계층적 페이징):
┌──────────┬──────────┬─────────┐
│Outer 페이지│Inner 페이지│ Offset │
│   번호    │   번호    │        │
└──────────┴──────────┴─────────┘
```

**주소 변환 과정:**

1. Outer 페이지 번호 → 페이지 테이블의 페이지 찾기
2. Inner 페이지 번호 → 프레임 번호 찾기
3. Offset 더하여 물리 주소 완성

---

## 14-3. 페이지 교체와 프레임 할당

가상 메모리로 큰 프로세스 실행이 가능해졌지만, 여전히 물리 메모리 크기는 한정되어 있습니다.

### 요구 페이징 (Demand Paging)

프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 **필요한 페이지만** 메모리에 적재하는 기법입니다.

**요구 페이징 동작 과정:**

```
1. CPU가 특정 페이지 접근 명령어 실행
2. 해당 페이지가 메모리에 있는가?
   ├─ YES (유효비트=1) → 3-1. 프레임에 접근
   └─ NO (유효비트=0) → 3-2. 페이지 폴트 발생
4. 페이지 폴트 처리: 페이지를 메모리로 적재, 유효비트=1
5. 1번으로 돌아가서 재실행
```

**순수 요구 페이징:** 아예 처음부터 아무 페이지도 적재하지 않고 실행 시작

### 페이지 교체 알고리즘

**페이지 참조열:** CPU가 참조하는 페이지 중 연속된 페이지를 생략한 페이지열

**예시:**

```
CPU 접근 순서: 2 2 2 3 5 5 3 3 7
페이지 참조열: 2 3 5 3 7 (연속 페이지 생략)
```

#### FIFO 페이지 교체 알고리즘

**예시 상황:**

- 사용 가능한 프레임: 3개
- 페이지 참조열: 2 3 1 3 5 2 3 4 2 3

| 시점 | 참조 페이지 | 프레임 상태 | 페이지 폴트   |
| ---- | ----------- | ----------- | ------------- |
| 1    | 2           | [2, -, -]   | × (초기 할당) |
| 2    | 3           | [2, 3, -]   | × (초기 할당) |
| 3    | 1           | [2, 3, 1]   | × (초기 할당) |
| 4    | 3           | [2, 3, 1]   | ×             |
| 5    | 5           | [5, 3, 1]   | ○ (2 교체)    |
| 6    | 2           | [5, 2, 1]   | ○ (3 교체)    |
| 7    | 3           | [5, 2, 3]   | ○ (1 교체)    |
| 8    | 4           | [4, 2, 3]   | ○ (5 교체)    |
| 9    | 2           | [4, 2, 3]   | ×             |
| 10   | 3           | [4, 2, 3]   | ×             |

**총 페이지 폴트: 4회**

#### 최적 페이지 교체 알고리즘

가장 오랫동안 사용하지 않을 페이지를 교체

| 시점 | 참조 페이지 | 프레임 상태 | 페이지 폴트   | 교체 이유                    |
| ---- | ----------- | ----------- | ------------- | ---------------------------- |
| 1-3  | 2,3,1       | [2, 3, 1]   | × (초기 할당) | -                            |
| 4    | 3           | [2, 3, 1]   | ×             | -                            |
| 5    | 5           | [2, 5, 1]   | ○             | 3 교체 (다음에 7번째에 사용) |
| 6-7  | 2,3         | [2, 5, 3]   | ×             | -                            |
| 8    | 4           | [4, 5, 3]   | ○             | 2 교체 (다음에 9번째에 사용) |
| 9-10 | 2,3         | [4, 2, 3]   | ×             | -                            |

**총 페이지 폴트: 2회** (이론상 최적)

#### LRU 페이지 교체 알고리즘

가장 오랫동안 사용되지 않은 페이지를 교체

| 시점 | 참조 페이지 | 프레임 상태 | 페이지 폴트   | 교체된 페이지         |
| ---- | ----------- | ----------- | ------------- | --------------------- |
| 1-3  | 2,3,1       | [2, 3, 1]   | × (초기 할당) | -                     |
| 4    | 3           | [2, 3, 1]   | ×             | -                     |
| 5    | 5           | [5, 3, 1]   | ○             | 2 (가장 오래 전 사용) |
| 6    | 2           | [5, 3, 2]   | ○             | 1 (가장 오래 전 사용) |
| 7    | 3           | [5, 3, 2]   | ×             | -                     |
| 8    | 4           | [4, 3, 2]   | ○             | 5 (가장 오래 전 사용) |
| 9-10 | 2,3         | [4, 3, 2]   | ×             | -                     |

**총 페이지 폴트: 3회**

### 스래싱과 프레임 할당

#### 스래싱 (Thrashing)

페이지 교체가 너무 자주 발생하여 CPU 이용률이 급격히 감소하는 현상

```
CPU 이용률
    │    ┌─ 정상 작동 구간
    │   ╱│
    │  ╱ │
    │ ╱  │╲ ← 스래싱 발생!
    │╱   │ ╲
    └────────────────→ 멀티프로그래밍 정도
```

**원인:** 프로세스에 할당된 프레임 수 부족

#### 프레임 할당 방식

##### 정적 할당 방식

프로세스 실행 과정을 고려하지 않고 크기만 고려

| 방식          | 설명                                  | 예시                                    |
| ------------- | ------------------------------------- | --------------------------------------- |
| **균등 할당** | 모든 프로세스에 동일한 프레임 수 할당 | 100개 프레임, 5개 프로세스 → 각각 20개  |
| **비례 할당** | 프로세스 크기에 비례하여 할당         | 크기가 2배인 프로세스는 2배 많은 프레임 |

##### 동적 할당 방식

프로세스 실행 중 페이지 참조 패턴을 고려

**1. 작업 집합 모델**

- 프로세스가 일정 기간 동안 참조한 페이지 집합을 '작업 집합'이라 함
- 100개 페이지로 구성된 프로세스라도 자주 참조하는 페이지는 일부분
- 작업 집합 크기만큼만 프레임 할당

**2. 페이지 폴트 빈도 기반**

```
페이지 폴트율
    │
상한선├─────────────────
    │     ↑ 프레임 추가 할당
    │
    │     ↓ 프레임 회수
하한선├─────────────────
    └────────────────→ 할당된 프레임 수
```

**동작 원리:**

- 페이지 폴트율 > 상한선 → 프레임 추가 할당
- 페이지 폴트율 < 하한선 → 프레임 회수

---

## 정리

가상 메모리는 연속 메모리 할당의 외부 단편화 문제를 해결하며, 물리 메모리보다 큰 프로세스의 실행을 가능하게 합니다. 페이징 기법을 통해 효율적인 메모리 관리가 가능하며, 적절한 페이지 교체 알고리즘과 프레임 할당 전략을 통해 시스템 성능을 최적화할 수 있습니다.
