# Chapter 14: 가상 메모리 퀴즈 정답

## 단답형 정답

### 1. **스와핑(Swapping)**

### 2. **외부 단편화(External Fragmentation)**

### 3. **페이지(Page)와 프레임(Frame)**

### 4. **TLB(Translation Lookaside Buffer)**

### 5. **수정 비트(Dirty Bit) 또는 더티 비트**

### 6. **요구 페이징(Demand Paging)**

### 7. **스래싱(Thrashing)**

---

## 서술형 정답

### 1. 스와핑 기법 설명

**스와핑**: 메모리에 적재된 프로세스들 중 현재 실행되지 않는 프로세스(대기 상태 프로세스나 오랫동안 사용되지 않은 프로세스)를 임시로 보조기억장치의 스왑 영역으로 이동시키고, 생긴 빈 공간에 다른 프로세스를 적재하여 실행하는 기법이다.

- **스왑 아웃**: 메모리에서 스왑 영역(보조기억장치)으로 프로세스를 이동시키는 것
- **스왑 인**: 스왑 영역에서 메모리로 프로세스를 다시 가져오는 것

**장점**: 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다. 예를 들어, 프로세스 A, B, C, D의 크기 합이 메모리 크기보다 크더라도 스와핑을 통해 4개의 프로세스를 동시에 실행할 수 있다.

### 2. 연속 메모리 할당의 3가지 방식

- **최초 적합**: OS가 메모리 내의 빈 공간을 순서대로 검색하다가 적재 가능한 첫 번째 공간에 프로세스를 배치하는 방식. 검색을 최소화하여 빠른 할당이 가능하다.
- **최적 적합**: 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식. 공간 효율성을 추구한다.
- **최악 적합**: 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식. 큰 단편화를 방지하려고 한다.

### 3. 외부 단편화 문제

**외부 단편화 발생 이유**: 메모리에 충분한 빈 공간이 있지만 불연속적으로 분산되어 있어서 연속된 공간을 요구하는 프로세스를 할당할 수 없는 현상이다.

**구체적 예시**: 총 50MB의 빈 공간이 20MB와 30MB로 나뉘어 있다면 50MB 크기의 프로세스는 할당할 수 없다. 빈 공간의 총합은 충분하지만 연속되지 않기 때문이다.

**해결 방법**:

1. **메모리 압축(Compaction)**: 흩어진 빈 공간들을 하나로 모으는 방법이지만, 시스템 중단과 오버헤드가 발생하며 효율적인 압축 방법을 결정하기 어렵다는 단점이 있다.
2. **가상 메모리 기법**: 페이징 기법을 통해 프로세스를 불연속적으로 할당하여 외부 단편화를 근본적으로 해결한다.

### 4. 페이징 기법의 내부 단편화

**내부 단편화 발생 이유**: 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것이 아니기 때문이다.

**구체적 예시**: 페이지 크기가 10KB이고 프로세스 크기가 108KB라면, 프로세스는 11개의 페이지로 나뉘게 된다 (10KB × 10페이지 + 8KB × 1페이지). 마지막 페이지는 8KB만 사용하고 2KB는 낭비되는데, 이것이 내부 단편화이다.

**페이지 크기 설정 시 고려 요소**:

- **페이지 크기를 너무 작게 설정**: 내부 단편화는 줄어들지만 페이지 테이블의 크기가 커져서 페이지 테이블이 차지하는 공간이 낭비된다.
- **페이지 크기를 너무 크게 설정**: 페이지 테이블 크기는 작아지지만 내부 단편화가 커진다.
- **최적화**: 내부 단편화를 최소화하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지 크기를 조정하는 것이 중요하다.

### 5. 페이지 테이블 엔트리의 4가지 비트

- **유효 비트**: 해당 페이지가 현재 메모리에 적재되어 있는지 여부를 나타냄 (1: 메모리 적재, 0: 스왑아웃 상태)
- **보호 비트**: 페이지에 대한 접근 권한을 나타냄 (읽기/쓰기/실행 권한). 0이면 읽기만 가능하고 1이면 쓰기도 가능함
- **참조 비트**: CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타냄 (1: 접근함, 0: 접근 안 함)
- **수정 비트(Dirty Bit)**: 해당 페이지에 쓰기 작업이 수행되었는지 여부를 나타냄 (1: 수정됨, 0: 수정 안 됨)

**수정 비트의 중요성**: 페이지가 스왑 아웃될 때 보조기억장치에 쓰기 작업을 해야 하는지 판단하기 위함이다. 수정 비트가 0인 페이지(한 번도 수정되지 않은 페이지)는 보조기억장치의 내용과 동일하므로 단순히 새로운 페이지로 덮어쓰기만 하면 되지만, 수정 비트가 1인 페이지는 변경된 내용을 보조기억장치에 저장하는 추가 작업이 필요하다.

### 6. LRU 페이지 교체 알고리즘 과정

**동작 과정**:

1. 페이지 2: 프레임 [2, -, -] - 초기 할당이므로 페이지 폴트 없음
2. 페이지 3: 프레임 [2, 3, -] - 초기 할당이므로 페이지 폴트 없음
3. 페이지 1: 프레임 [2, 3, 1] - 초기 할당이므로 페이지 폴트 없음
4. 페이지 3: 프레임 [2, 3, 1] - 이미 존재하므로 페이지 폴트 없음
5. 페이지 5: 프레임 [5, 3, 1] - 가장 오래 전에 사용된 2를 교체, **페이지 폴트 발생**
6. 페이지 2: 프레임 [5, 3, 2] - 가장 오래 전에 사용된 1을 교체, **페이지 폴트 발생**
7. 페이지 3: 프레임 [5, 3, 2] - 이미 존재하므로 페이지 폴트 없음
8. 페이지 4: 프레임 [4, 3, 2] - 가장 오래 전에 사용된 5를 교체, **페이지 폴트 발생**
9. 페이지 2: 프레임 [4, 3, 2] - 이미 존재하므로 페이지 폴트 없음
10. 페이지 3: 프레임 [4, 3, 2] - 이미 존재하므로 페이지 폴트 없음

**총 페이지 폴트 횟수: 3회**

### 7. 쓰기 시 복사(Copy-on-Write) 기법

**동작 원리**: fork() 시스템 호출이 발생하면 부모와 자식 프로세스가 동일한 메모리 프레임을 공유한다. 읽기 작업만 수행한다면 이 상태가 계속 유지되지만, 부모나 자식 프로세스 중 하나가 쓰기 작업을 수행하는 순간 해당 페이지가 별도의 공간으로 복제되며 페이지 테이블이 업데이트된다.

**장점**:

- **프로세스 생성 시간 단축**: 초기에 모든 메모리를 복사할 필요가 없어 fork() 실행 속도가 빨라진다.
- **메모리 공간 절약**: 읽기 전용으로 사용되는 페이지들은 계속 공유되어 메모리 사용량이 줄어든다.
- **효율적인 자원 활용**: 실제로 수정이 필요한 페이지만 복제하여 불필요한 복사를 방지한다.

### 8. 스래싱과 동적 프레임 할당

**스래싱 발생 원인**: 프로세스에 할당된 프레임 수가 부족하여 페이지 교체가 너무 자주 발생하는 것이 근본 원인이다. 이로 인해 CPU가 페이지 교체에 너무 많은 시간을 소비하게 되어 CPU 이용률이 급격히 감소한다.

**동적 할당 방식**:

1. **작업 집합 모델**: 프로세스가 일정 기간 동안 참조한 페이지 집합을 '작업 집합'이라고 한다. 프로세스가 100개의 페이지로 구성되어 있다고 해서 100개 모두를 고르게 참조하지는 않으며, 자주 참조하는 페이지 집합이 존재한다. 이 작업 집합의 크기만큼 프레임을 할당해주어 빈번한 페이지 교체를 방지하는 방식이다.

2. **페이지 폴트 빈도 기반**: 페이지 폴트율에 대한 상한선과 하한선을 설정하는 방식이다. 페이지 폴트율이 상한선보다 높으면 해당 프로세스가 너무 적은 프레임을 가지고 있다고 판단하여 프레임을 추가로 할당하고, 페이지 폴트율이 하한선보다 낮으면 해당 프로세스가 너무 많은 프레임을 가지고 있다고 판단하여 프레임을 회수하는 방식이다.
