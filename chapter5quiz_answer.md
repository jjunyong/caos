## 정답

### 객관식

1. b
2. c
3. b
4. d
5. b
6. b
7. b
8. c

### 단답형

9. 명령어 사이클
10. 멀티코어
11. 논리 프로세서
12. 명령어 파이프라인
13. 데이터 위험 (데이터 해저드)
14. 명령어 집합 구조(ISA: Instruction Set Architecture)
15. load, store

### 서술형

16. (모범답안)
    클럭 속도는 CPU가 초당 처리할 수 있는 펄스의 수로, 클럭 속도가 높을수록 명령어 처리 속도가 빨라져 CPU 성능이 향상됩니다. 멀티코어 기술은 하나의 CPU에 여러 개의 연산 코어를 탑재하여 여러 작업을 동시에 병렬로 처리할 수 있게 함으로써 전체적인 성능을 향상시킵니다. 멀티스레드 기술은 하나의 코어가 여러 개의 명령어 스트림(하드웨어 스레드)을 동시에 처리할 수 있게 하여, 한 스레드가 대기 상태일 때 다른 스레드를 실행함으로써 CPU 자원의 활용도를 높이고 성능을 향상시킵니다.

17. (모범답안)
    명령어 파이프라인은 명령어 처리 과정을 여러 단계(인출→해석→실행→저장)로 나누어 각 단계를 동시에 처리함으로써 전체 명령어 처리 속도를 향상시키는 기법입니다. 파이프라인에는 세 가지 주요 위험이 있습니다. 첫째, 데이터 위험은 이전 명령어의 결과가 다음 명령어의 입력으로 필요할 때 발생합니다. 둘째, 제어 위험은 분기 명령어로 인해 명령어 실행 흐름이 변경될 때 발생합니다. 셋째, 구조적 위험은 서로 다른 명령어가 동일한 하드웨어 자원을 동시에 사용하려고 할 때 발생합니다. 이러한 위험들은 파이프라인의 효율성을 저하시키므로 적절한 해결책이 필요합니다.

18. (모범답안)
    CISC(Complex Instruction Set Computer)는 복잡하고 다양한 명령어, 가변 길이 명령어, 다양한 주소 지정 방식을 제공하며, 명령어 실행에 여러 클럭이 필요합니다. x86 아키텍처가 대표적입니다. CISC의 장점은 복잡한 작업을 하나의 명령어로 수행할 수 있어 코드 크기가 작고 메모리 사용이 효율적이나, 단점은 파이프라이닝 구현이 어렵고 명령어 실행 시간이 일정하지 않다는 것입니다.

RISC(Reduced Instruction Set Computer)는 단순하고 적은 수의 명령어, 고정 길이 명령어, 제한된 주소 지정 방식을 사용하며, 대부분의 명령어가 1클럭 내에 실행됩니다. ARM 아키텍처가 대표적입니다. RISC는 메모리 접근 명령어가 load와 store로 제한되어 있고 범용 레지스터를 적극 활용합니다. RISC의 장점은 파이프라이닝 구현이 용이하고 명령어 실행 시간이 예측 가능하다는 것이나, 단점은 같은 작업 수행 시 더 많은 명령어가 필요하여 코드 크기가 커진다는 것입니다.

19. (모범답안)
    슈퍼스칼라 기술은 여러 개의 명령어를 동시에 인출하고 실행할 수 있는 기술로, 파이프라인의 각 단계에서 여러 명령어를 병렬로 처리함으로써 명령어 처리량을 증가시켜 CPU 성능을 향상시킵니다. 그러나 이 기술은 파이프라인 위험을 더욱 복잡하게 만들어 고도의 관리가 필요합니다.

비순차적 명령어 처리 기법은 명령어 의존성을 고려하여 준비된 명령어를 먼저 실행하는 방식으로, '합법적인 새치기'와 같은 개념입니다. 이 기법은 명령어 간 의존성으로 인한 파이프라인 지연을 최소화하고, CPU의 실행 유닛들이 유휴 상태에 있는 시간을 줄임으로써 전체적인 CPU 성능을 향상시킵니다.

20. (모범답안)
    하드웨어적 스레드는 하나의 코어가 동시에 처리하는 명령어 단위로, CPU 내부에서 물리적으로 독립된 명령어 스트림을 의미합니다. 반면 소프트웨어적 스레드는 하나의 프로그램에서 독립적으로 실행되는 단위로, 운영체제에 의해 관리되는 논리적 실행 흐름입니다.

하드웨어적 스레드가 CPU 성능에 중요한 이유는 다음과 같습니다. 첫째, 하드웨어 스레드를 통해 하나의 코어가 여러 명령어 스트림을 동시에 처리할 수 있어 CPU 리소스 활용도가 높아집니다. 둘째, 한 스레드가 메모리 접근이나 I/O 작업으로 대기 상태일 때 다른 스레드가 CPU를 사용할 수 있어 CPU 유휴 시간이 감소합니다. 셋째, 하드웨어적 스레드는 운영체제에 논리 프로세서로 인식되어 소프트웨어적 병렬 처리를 물리적으로 지원합니다. 이러한 이유로 멀티스레드 프로세서는 단일 스레드 프로세서보다 더 효율적인 성능을 제공할 수 있습니다.

---

1.  명령어별 주소 지정 방식

- **MOV AX, 25** (명령어 1)

  - **즉시 주소 지정(Immediate Addressing)**: 피연산자 값 25가 명령어에 직접 포함됨

- **MOV BX, [200]** (명령어 2)

  - **직접 주소 지정(Direct Addressing)**: 메모리 주소 200이 명령어에 직접 명시됨

- **MOV CX, [BX]** (명령어 3)

  - **레지스터 간접 주소 지정(Register Indirect Addressing)**: BX 레지스터의 값이 메모리 주소로 사용됨

- **MOV DX, [BX+5]** (명령어 4)

  - **베이스 + 변위 주소 지정(Base+Displacement Addressing)**: BX 레지스터의 값에 5를 더한 값이 메모리 주소로 사용됨

- **ADD AX, BX** (명령어 5)

  - **레지스터 주소 지정(Register Addressing)**: 피연산자로 레지스터가 사용됨

- **MOV [300], AX** (명령어 6)

  - **직접 주소 지정(Direct Addressing)**: 메모리 주소 300이 명령어에 직접 명시됨

- **PUSH AX** (명령어 7)

  - **암시적 주소 지정(Implicit Addressing)**: 스택 포인터(SP)가 암시적으로 사용됨

- **POP SI** (명령어 8)
  - **암시적 주소 지정(Implicit Addressing)**: 스택 포인터(SP)가 암시적으로 사용됨

2. 명령어 실행 후 레지스터 값

```
AX = 235    (명령어 1에서 25로 설정, 명령어 5에서 BX 값인 210을 더함)
BX = 210    (명령어 2에서 메모리 주소 200의 값으로 설정)
CX = 50     (명령어 3에서 메모리 주소 210의 값으로 설정)
DX = 75     (명령어 4에서 메모리 주소 215의 값으로 설정)
SI = 235    (명령어 8에서 스택에서 POP한 AX 값으로 설정)
```

3. 명령어 6 실행 후 메모리 주소 300의 값

```
메모리 주소 300의 값 = 235 (AX의 값이 저장됨)
```

4. 명령어 7 실행 후 SP 값

```
실행 전 SP = 500
실행 후 SP = 498 (16비트 값인 AX가 스택에 저장되어 2바이트 감소)
```

5. 사용되지 않은 주소 지정 방식

```
b) 상대 주소 지정

상대 주소 지정은 현재 명령어 포인터(IP)에 상대적인 오프셋을 더하여 주소를 계산하는 방식으로,
주로 분기 명령어(JMP, CALL 등)에서 사용됩니다. 위 명령어 시퀀스에는 이러한 분기 명령어가 포함되어 있지 않습니다.
```
